#include "minishell_hr.h"
typedef struct  s_lst
{
    struct s_lst   *next;
    char            *p2e;
    char            **argv;
}               t_lst;

typedef struct  pp
{
    int     fd;
    char    *dup_of;
    int     npipe;
    int     closed;
}               pipe_fd;

int pipe_count = 0;

#define DUP(x, y) wrap_dup(x, y, #y)

pipe_fd wrap_dup(pipe_fd *pfd, int fd, char *dof)
{
    pfd->dup_of = isdigit(dof[0]) ? strdup(dof) : strdup("dup pipe");
    pfd->fd = dup(fd);
    pfd->npipe = pipe_count;
    pfd->closed = 0;
    return (*pfd);
}

void wrap_close(pipe_fd * pfd)
{
    close(pfd->fd);
    free(pfd->dup_of);
    pfd->dup_of = NULL;
    pfd->npipe = -1;
    pfd->closed = 1;
}

int wrap_pipe(pipe_fd *pfd)
{
    int fd[2];
    int ret;

    ret = pipe(fd);
    pipe_count++;
    pfd[0].fd = fd[0];
    pfd[1].fd = fd[1];
    pfd[0].dup_of = strdup("pipe");
    pfd[1].dup_of = strdup("pipe");
    pfd[0].closed = 0;
    pfd[1].closed = 0;
    pfd[0].npipe = pipe_count;
    pfd[1].npipe = pipe_count;
    return (ret);
}

void add_node(t_lst **head, char *p2e, char **av)
{
    t_lst   **tracer;

    tracer = head;
    while (*tracer)
        tracer = &(*tracer)->next;
    *tracer = malloc(sizeof(**tracer));
    (*tracer)->p2e = strdup(p2e);
    int len;
    for (len = 0; av[len]; len++);
    (*tracer)->argv = malloc(sizeof(char*) * (len + 1));
    for (len = 0; av[len]; len++)
        (*tracer)->argv[len] = strdup(av[len]);
    (*tracer)->argv[len] = NULL;
    (*tracer)->next = NULL;
}

int main(int ac, char **av, char **envp)
{
    t_lst *cmd_list = NULL;
    int i;
    pipe_fd dfd[2];
    pipe_fd read_fd;
    pipe_fd write_fd;

    add_node(&cmd_list, "/bin/ls", (char*[]){"ls", "-la", NULL});
    add_node(&cmd_list, "/usr/bin/grep", (char*[]){"grep", "test.c", NULL});
    add_node(&cmd_list, "/bin/cat", (char*[]){"cat", NULL});
    // for (t_lst **tr = &cmd_list; *tr; tr = &(*tr)->next)
    // {
    //     printf("cmd: %s\n", (*tr)->p2e);
    //     for (int y = 0; (*tr)->argv[y]; y++)
    //         printf("cmd: %s.arg[%d] = %s\n", (*tr)->p2e, y, (*tr)->argv[y]);
    // }
    i = 0;
    read_fd = DUP(&read_fd, 0);
    while (cmd_list)
    {
        fprintf(stderr, "current cmd: %s\n", cmd_list->argv[0]);
        dfd[0].fd = -1;
        dfd[1].fd = -1;
        if (cmd_list->next)
        {
            wrap_pipe(dfd);
            write_fd = DUP(&write_fd, dfd[1].fd);
            wrap_close(&dfd[1]);
        }
        else
        {
            write_fd = DUP(&write_fd, 1);
        }
        if (fork() == 0)
        {
            //child
            dup2(read_fd.fd, 0);
            dup2(write_fd.fd, 1);
            close(read_fd.fd);
            close(write_fd.fd);
            if (dfd[0].fd + 1)
                close(dfd[0].fd);
            if (dfd[1].fd + 1)
                close(dfd[1].fd);
            execve(cmd_list->p2e, cmd_list->argv, envp);
            exit(123);
        }
        else
        {
            //parent
            wait(NULL);
            wrap_close(&read_fd);
            wrap_close(&write_fd);
            if (cmd_list->next)
            {
                read_fd = DUP(&read_fd, dfd[0].fd);
                wrap_close(&dfd[0]);
            }
        }
        cmd_list = cmd_list->next;
    }
}